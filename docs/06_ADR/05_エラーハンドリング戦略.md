# エラーハンドリング戦略

## 背景

システム全体で一貫したエラーハンドリングを行い、適切なエラーレスポンスとログ出力を実現する必要がある。

エラーハンドリングにおいて以下の課題を解決する必要があった：
- エラーの種類（ビジネスエラー/システムエラー）によって異なる処理が必要
- APIレスポンスとして統一的なエラー形式が必要
- 運用時のトラブルシューティングのため適切なログ出力が必要
- エラーコードによる詳細な分類が必要

## 決定

### 1. エラーの2分類方式を採用

**BusinessError（ビジネスエラー）**
- ユーザーの操作や入力に起因するエラー
- 復旧可能でユーザーに詳細を伝えるべきエラー
- 例：バリデーションエラー、権限不足、重複登録

**IOError（システムエラー）**
- システム内部の問題に起因するエラー
- ユーザーには詳細を隠蔽すべきエラー
- 例：DB接続エラー、外部API通信エラー

### 2. エラーコード体系

HTTPステータスコードを拡張した6桁の数値コードを採用：
- 先頭3桁：HTTPステータスコード
- 後続3桁：詳細エラー番号

この方式により：
- エラーコードからHTTPステータスを機械的に導出可能
- エラーの詳細分類が可能
- 運用時のエラー特定が容易

### 3. ログ出力戦略

BusinessErrorにもErrorLevel（WARN/ERROR）を持たせ、重要度に応じたログ出力を行う。

理由：
- 全てのBusinessErrorを無視すると、異常な頻度で発生する場合の検知が困難
- 重要度の高いBusinessError（認可エラー等）は監視対象とすべき
- WARNレベルなら通常フローとして扱いつつ監視も可能

### 4. トランザクション制御との連携

Result型だけでなく、既存のSpringトランザクション機構と連携するため、シンプルな例外ラッパーを用意：
- `AppException`：全てのAppErrorをラップする汎用例外クラス
- UseCase層で`Result<T, AppError>`から例外への変換を行う
- GlobalExceptionHandlerで`AppException`をキャッチし、内包するエラー型に応じて処理

この方式により：
- 例外クラスが1つで済み、シンプル
- AppErrorの型階層をそのまま活かせる
- トランザクション制御は`@Transactional`のデフォルト動作に任せる

## 結果

この設計により以下が実現される：

1. **一貫性のあるエラー処理**
   - 全てのエラーが統一的な形式でハンドリングされる
   - APIレスポンスが予測可能な形式になる

2. **運用性の向上**
   - エラーコードによる問題の特定が容易
   - 適切なログレベルによる監視・アラートの設定が可能

3. **保守性の向上**
   - エラーの種類が明確に分類され、新しいエラーの追加が容易
   - エラーコードからHTTPステータスが自動導出され、一貫性が保たれる

## 代替案

1. **エラーコードを文字列にする案**
   - 検討したが、HTTPステータスの導出が複雑になるため却下
   - 数値の方が範囲管理や順序付けが容易

2. **BusinessErrorをログ出力しない案**
   - 当初検討したが、異常パターンの検知が困難になるため却下
   - ErrorLevelによる制御を採用

3. **例外クラスを使わずResult型のみ使用する案**
   - Springのトランザクション制御との相性が悪いため却下
   - ハイブリッドアプローチを採用

4. **BusinessError/IOError毎に個別の例外クラスを作る案**
   - ApplicationException、SystemExceptionの2つを検討
   - 例外クラスが増えて複雑になるため、単一のAppExceptionを採用